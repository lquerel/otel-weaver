// SPDX-License-Identifier: Apache-2.0

//! JSON Schema validator for semantic convention files.

use crate::semconv::SemConvSpec;
use crate::Error;
use crate::Error::{CompoundError, InvalidSemConvSpec};
use miette::{SourceOffset, SourceSpan};
use saphyr::{LoadableYamlNode, Marker, Yaml};
use std::fs;
use std::path::Path;

/// JSON schema validator for semantic conventions.
pub struct JsonSchemaValidator {
    /// JSON schema validator instance
    validator: jsonschema::Validator,
}

impl JsonSchemaValidator {
    /// Creates a new JSON schema validator.
    pub fn new() -> Self {
        // Generate the JSON schema for the SemConvSpec struct using Schemars
        let json_schema = schemars::schema_for!(SemConvSpec);
        let json_schema_value = serde_json::to_value(&json_schema)
            // Should never happen as we expert Schemars to work
            .expect("Failed to convert schema to JSON value");
        let validator = jsonschema::Validator::new(&json_schema_value)
            // Should never happen as we expert Schemars to work
            .expect("Failed to create JSON schema validator");

        JsonSchemaValidator { validator }
    }

    /// Validates the given JSON schema against the provided schema.
    pub fn validate_yaml(
        &self,
        yaml_value: serde_yaml::Value,
        provenance: &str,
        serde_error: serde_yaml::Error,
    ) -> Result<(), Error> {
        // Convert YAML value to JSON value as the validator works with JSON
        let json = match serde_json::to_value(yaml_value) {
            Ok(v) => v,
            Err(_) => {
                // Fallback to original serde error
                return Err(InvalidSemConvSpec {
                    path_or_url: provenance.to_owned(),
                    location: serde_error
                        .location()
                        .map(|loc| format!("{}:{}", loc.line(), loc.column()))
                        .unwrap_or("NA".to_owned()),
                    src: "NA".to_owned(),
                    err_span: None,
                    error: serde_error.to_string(),
                });
            }
        };

        let mut errors = vec![];

        // Iterate over errors generated by the validator
        for error in self.validator.iter_errors(&json) {
            let src = serde_json::to_string_pretty(error.instance.as_ref())
                .unwrap_or_else(|_| "NA".to_owned());
            let src_size = src.len();

            errors.push(InvalidSemConvSpec {
                path_or_url: provenance.to_owned(),
                location: error.instance_path.to_string(),
                src,
                err_span: Some(SourceSpan::new(SourceOffset::from(0), src_size)),
                error: error.to_string(),
            });
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(CompoundError(errors))
        }
    }
}

/// Represents a position in the source file
#[derive(Debug, Clone, PartialEq)]
struct Position {
    line: usize,
    column: usize,
    byte_offset: usize,
}

/// Represents a block's boundaries in the source
#[derive(Debug, Clone)]
struct BlockPosition {
    start: Position,
    end: Position,
}

/// Parsed simple XPath components
#[derive(Debug, Clone)]
enum PathComponent {
    Key(String),
    Index(usize),
}

/// Represents a YAML document with its content and parsed structure.
#[derive(Debug)]
pub struct YamlDocument<'a> {
    content: &'a str,
    yaml: Yaml<'a>,
    lines: Vec<usize>,
}

fn source_span_from_marker(
    marker: &Marker,
    line_before: usize,
    line_after: usize,
    lines: &[usize],
    source_len: usize,
) -> SourceSpan {
    // Offset (in bytes) of `line_before` lines before the error location
    let start = lines[marker.line().saturating_sub(line_before)];
    // Number of bytes between the start and `line_after` lines after the error location
    let len = if marker.line() + line_after < lines.len() {
        lines[marker.line() + line_after] - start
    } else {
        source_len - start
    };
    SourceSpan::new(SourceOffset::from(start), len)
}

impl<'a> YamlDocument<'a> {
    /// Create a new YamlDocument from a string slice
    pub fn from_str(content: &'a str) -> Result<Self, Error> {
        // Build line offset index for position calculations
        let mut lines = vec![0];
        for (i, byte) in content.bytes().enumerate() {
            if byte == b'\n' {
                lines.push(i + 1);
            }
        }

        let docs = Yaml::load_from_str(content).map_err(|e|
            InvalidSemConvSpec {
                path_or_url: "inline".to_owned(),
                location: format!("{}:{}", e.marker().line(), e.marker().col()),
                src: content.to_string(),
                err_span: Some(source_span_from_marker(e.marker(), 2, 2, &lines, content.len())),
                error: e.to_string(),
            }
        )?;
        let yaml = docs.into_iter().next().ok_or("No YAML document found").map_err(|e|
            InvalidSemConvSpec {
                path_or_url: "inline".to_owned(),
                location: "NA".to_owned(),
                src: content.to_string(),
                err_span: None,
                error: e.to_string(),
            }
        )?;

        Ok(YamlDocument {
            content,
            yaml,
            lines,
        })
    }

    /// Find the position of a YAML block using simple XPath syntax
    pub fn find_block_position(
        &self,
        xpath: &str,
    ) -> Result<BlockPosition, Box<dyn std::error::Error>> {
        let path = self.parse_xpath(xpath)?;
        let _block_content = self.navigate_to_block(&self.yaml, &path)?;
        self.find_block_boundaries(&path)
    }

    /// Parse simple XPath like "/groups/0/attributes/3"
    fn parse_xpath(&self, xpath: &str) -> Result<Vec<PathComponent>, Box<dyn std::error::Error>> {
        if !xpath.starts_with('/') {
            return Err("XPath must start with '/'".into());
        }

        let components: Result<Vec<_>, _> = xpath[1..] // Skip leading '/'
            .split('/')
            .filter(|s| !s.is_empty())
            .map(|component| {
                // Try to parse as number first (array index)
                if let Ok(index) = component.parse::<usize>() {
                    Ok(PathComponent::Index(index))
                } else {
                    Ok(PathComponent::Key(component.to_string()))
                }
            })
            .collect();

        components
    }

    /// Navigate through the YAML structure following the path
    /// Returns an owned Yaml value to avoid lifetime issues
    fn navigate_to_block<'b>(
        &self,
        yaml: &Yaml<'b>,
        path: &[PathComponent],
    ) -> Result<Yaml<'b>, Box<dyn std::error::Error>> {
        let mut current = yaml.clone(); // Start with owned value

        for component in path {
            match component {
                PathComponent::Key(key) => {
                    // Use saphyr's Index trait - this returns owned Yaml
                    current = current[key.as_str()].clone();

                    // Check if we got BadValue (saphyr's way of indicating missing keys)
                    if current.is_badvalue() {
                        return Err(format!("Key '{}' not found", key).into());
                    }
                }
                PathComponent::Index(index) => {
                    // Use saphyr's Index trait - this returns owned Yaml
                    current = current[*index].clone();

                    // Check if we got BadValue (out of bounds or wrong type)
                    if current.is_badvalue() {
                        return Err(
                            format!("Index {} out of bounds or not a sequence", index).into()
                        );
                    }
                }
            }
        }

        Ok(current)
    }

    /// Find the actual byte positions of the block in the source
    /// This implements a more sophisticated approach to map logical nodes to source positions
    fn find_block_boundaries(
        &self,
        path: &[PathComponent],
    ) -> Result<BlockPosition, Box<dyn std::error::Error>> {
        if path.is_empty() {
            return Err("Empty path".into());
        }

        // Convert our logical path into a search strategy for the source text
        let lines: Vec<&str> = self.content.lines().collect();
        let mut current_line = 0;
        let mut current_indent = 0;

        // Navigate through each path component in the source
        for (component_idx, component) in path.iter().enumerate() {
            match component {
                PathComponent::Key(key) => {
                    // Find the key at the current or deeper indentation level
                    let target_pattern = format!("{}:", key);
                    let mut found = false;

                    for (line_idx, line) in lines.iter().enumerate().skip(current_line) {
                        if line.trim().is_empty() || line.trim().starts_with('#') {
                            continue;
                        }

                        let line_indent = self.get_line_indent(line);
                        let trimmed = line.trim();

                        // For the first component, any indent is ok
                        // For subsequent components, we need deeper or equal indent
                        let indent_ok = if component_idx == 0 {
                            true
                        } else {
                            line_indent >= current_indent
                        };

                        if indent_ok && (trimmed.starts_with(&target_pattern) || trimmed == key) {
                            current_line = line_idx;
                            current_indent = line_indent;
                            found = true;
                            break;
                        }
                    }

                    if !found {
                        return Err(format!("Could not find key '{}' in source", key).into());
                    }
                }
                PathComponent::Index(target_index) => {
                    // Find the nth occurrence of a list item (-) at appropriate indentation
                    let mut item_count = 0;
                    let mut found = false;

                    for (line_idx, line) in lines.iter().enumerate().skip(current_line + 1) {
                        if line.trim().is_empty() || line.trim().starts_with('#') {
                            continue;
                        }

                        let line_indent = self.get_line_indent(line);
                        let trimmed = line.trim();

                        // If we've gone back to same or lesser indent and it's not a list item,
                        // we've left the current sequence
                        if line_indent <= current_indent && !trimmed.starts_with('-') {
                            break;
                        }

                        // Look for list items at the right indentation level
                        if trimmed.starts_with('-') && line_indent > current_indent {
                            if item_count == *target_index {
                                current_line = line_idx;
                                current_indent = line_indent;
                                found = true;
                                break;
                            }
                            item_count += 1;
                        }
                    }

                    if !found {
                        return Err(format!(
                            "Could not find array index {} in source",
                            target_index
                        )
                            .into());
                    }
                }
            }
        }

        // Now find the end of this block
        let start_line = current_line;
        let start_indent = self.get_line_indent(lines[current_line]);
        let mut end_line = lines.len();

        // Find where this block ends (next item at same or lesser indentation)
        for (line_idx, line) in lines.iter().enumerate().skip(start_line + 1) {
            if line.trim().is_empty() || line.trim().starts_with('#') {
                continue;
            }

            let line_indent = self.get_line_indent(line);

            // If we find content at the same or lesser indentation, that's our end
            if line_indent <= start_indent {
                end_line = line_idx;
                break;
            }
        }

        // Convert line numbers to byte positions
        let start_byte = self.lines[start_line];
        let end_byte = if end_line < self.lines.len() {
            self.lines[end_line]
        } else {
            self.content.len()
        };

        Ok(BlockPosition {
            start: self.byte_to_position(start_byte),
            end: self.byte_to_position(end_byte),
        })
    }

    fn get_line_indent(&self, line: &str) -> usize {
        line.len() - line.trim_start().len()
    }

    fn byte_to_position(&self, byte_offset: usize) -> Position {
        for (line_num, &line_start) in self.lines.iter().enumerate() {
            if line_start > byte_offset {
                let prev_line_start = if line_num > 0 {
                    self.lines[line_num - 1]
                } else {
                    0
                };
                return Position {
                    line: line_num, // 0-based
                    column: byte_offset - prev_line_start,
                    byte_offset,
                };
            }
        }

        // Last line
        let last_line_start = self.lines.last().copied().unwrap_or(0);
        Position {
            line: self.lines.len(),
            column: byte_offset - last_line_start,
            byte_offset,
        }
    }
}

/// Owned version for cases where you need to own the data
/// This is useful when you can't guarantee the input string lifetime
pub struct OwnedYamlDocument {
    content: String,
    lines: Vec<usize>,
}

impl OwnedYamlDocument {
    /// Create a new OwnedYamlDocument from a file path
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let content = fs::read_to_string(path)?;
        Self::from_string(content)
    }

    /// Create a new OwnedYamlDocument from an owned string
    pub fn from_string(content: String) -> Result<Self, Box<dyn std::error::Error>> {
        // Build line offset index for position calculations
        let mut lines = vec![0];
        for (i, byte) in content.bytes().enumerate() {
            if byte == b'\n' {
                lines.push(i + 1);
            }
        }

        Ok(OwnedYamlDocument { content, lines })
    }

    /// Find the position of a YAML block using simple XPath syntax
    /// This creates a temporary YamlDocument with the appropriate lifetime
    pub fn find_block_position(
        &self,
        xpath: &str,
    ) -> Result<BlockPosition, Box<dyn std::error::Error>> {
        let yaml_doc = YamlDocument::from_str(&self.content)?;
        yaml_doc.find_block_position(xpath)
    }
}

/// Convenience functions for the most common use cases

/// Main function to find YAML block position by XPath from a file
pub fn find_yaml_block_position<P: AsRef<Path>>(
    yaml_file: P,
    xpath: &str,
) -> Result<BlockPosition, Box<dyn std::error::Error>> {
    let doc = OwnedYamlDocument::from_file(yaml_file)?;
    doc.find_block_position(xpath)
}

/// Find YAML block position by XPath from a string slice
pub fn find_yaml_block_position_str(
    yaml_content: &str,
    xpath: &str,
) -> Result<BlockPosition, Box<dyn std::error::Error>> {
    let doc = YamlDocument::from_str(yaml_content)?;
    doc.find_block_position(xpath)
}

/// Find YAML block position by XPath from an owned string
pub fn find_yaml_block_position_string(
    yaml_content: String,
    xpath: &str,
) -> Result<BlockPosition, Box<dyn std::error::Error>> {
    let doc = OwnedYamlDocument::from_string(yaml_content)?;
    doc.find_block_position(xpath)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_invalid_yaml_document() {
        let invalid_yaml = r#"
groups:
  - name: group1
    attributes:
      - attr1
      - attr2
      - attr3
{"invalid": true}      
  - name: group2
"#;
        let result = YamlDocument::from_str(invalid_yaml);
        
        assert!(result.is_err());
        if let Err(e) = result {
            assert!(matches!(e, InvalidSemConvSpec { .. }));
        }
    }

    #[test]
    fn test_empty_yaml_document() {
        let invalid_yaml = r#""#;
        let result = YamlDocument::from_str(invalid_yaml);

        assert!(result.is_err());
        if let Err(e) = result {
            assert!(matches!(e, InvalidSemConvSpec { .. }));
        }
    }

    #[test]
    fn test_valid_yaml_document() {
        let yaml = r#"groups:
  - name: group1
    attributes:
      - attr1
      - attr2
      - attr3
  - name: group2
"#;
        let yaml = YamlDocument::from_str(yaml).expect("Failed to parse valid YAML");
        let block_pos = yaml.find_block_position("/groups/0/attributes/1")
            .expect("Failed to find block position in valid YAML");
        dbg!(block_pos);
        dbg!(yaml);
    }

    #[test]
    fn test_lifetime_aware_parsing() {
        let yaml_content = "groups:\n  - name: test";
        let doc = YamlDocument::from_str(yaml_content).unwrap();
        let path = doc.parse_xpath("/groups/0").unwrap();

        assert_eq!(path.len(), 2);
        matches!(path[0], PathComponent::Key(ref k) if k == "groups");
        matches!(path[1], PathComponent::Index(0));
    }

    #[test]
    fn test_owned_version() {
        let yaml_content = r#"
groups:
  - name: group1
    attributes:
      - attr1
      - attr2
      - attr3
  - name: group2
"#
            .trim()
            .to_string();

        let doc = OwnedYamlDocument::from_string(yaml_content).unwrap();
        let result = doc.find_block_position("/groups/0/attributes/1");

        assert!(result.is_ok());
        let pos = result.unwrap();
        println!("Found block at lines {}-{}", pos.start.line, pos.end.line);
    }

    #[test]
    fn test_convenience_functions() {
        let yaml_content = "groups:\n  - name: test";

        // Test string slice version
        let result = find_yaml_block_position_str(yaml_content, "/groups/0");
        assert!(result.is_ok());

        // Test owned string version
        let result = find_yaml_block_position_string(yaml_content.to_string(), "/groups/0");
        assert!(result.is_ok());
    }

    #[test]
    fn test_semconv() {
        let yaml_content = r#"
groups:
  - id: attributes.log
    type: attribute_group
    brief: "Describes Log attributes"
    attributes:
      - id: log.iostream
        stability: stable
        requirement_level: opt_in
        brief: >
          The stream associated with the log. See below for a list of well-known values.
        type:
          members:
            - id: stdout
              stability: stable
              value: 'stdout'
              brief: 'Logs from stdout stream'
            - id: stderr
              stability: stable
              value: 'stderr'
              brief: 'Events from stderr stream'
"#
            .trim()
            .to_string();

        let doc = OwnedYamlDocument::from_string(yaml_content).unwrap();
        let result = doc.find_block_position("/groups/0/attributes/0/type/members/1");

        assert!(result.is_ok());
        let pos = result.unwrap();
        println!("Found block at lines {}-{}", pos.start.line, pos.end.line);
    }

    #[test]
    fn debug_yaml_variants() {
        let yaml_content = r#"
mapping:
  key: value
sequence:
  - item1
  - item2
"#;
        let docs = Yaml::load_from_str(yaml_content).unwrap();
        let doc = &docs[0];

        // This test will show you the exact variant structure used by saphyr
        println!("Document structure: {:#?}", doc);

        // Test the Index-based navigation that should work regardless of variant names
        println!("Accessing mapping['key']: {:?}", &doc["mapping"]["key"]);
        println!("Accessing sequence[0]: {:?}", &doc["sequence"][0]);

        // Test badvalue detection
        println!("Non-existent key: {:?}", &doc["nonexistent"]);
        println!("Is badvalue: {}", doc["nonexistent"].is_badvalue());
    }
}
