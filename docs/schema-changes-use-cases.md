# Schema Changes

This document describes the different types of schema changes that can be made to a semantic convention registry and
outlines how to handle them both within the semantic convention registry and in the schema changes format generated
by Weaver.

The schema changes format generated by Weaver must be sufficiently comprehensive to support the following use cases:

- **Generation of meaningful migration guides**: These guides should preserve the intent and semantics of the changes
  made by the semantic convention authors.
- **Implementation of SchemaProcessors**: These processors should enable automatic bidirectional conversion of telemetry
  data streams between different versions of a semantic convention registry.
- **Generation of Database Migration Scripts**: These scripts should accurately represent the changes made to a
  registry in a database system (e.g. SQL DDL scripts).

## Renaming

The `name` of an item in the semantic conventions acts as a persistent ID that should not change across versions.
However, there are cases where renaming an item becomes necessary. In such instances, the procedure is to deprecate
the old item and introduce a new item with the updated name. The `deprecated` field of the old item should reference the
new item as its replacement, along with additional information about the type of renaming.

Several forms of renaming are supported within the semantic conventions:

- **Basic Renaming**: A single item is renamed to a new name. Backward and forward transformations are straightforward
  in this case and can be automatically inferred.
- **Conditional Renaming**: An item is renamed to a new name based on specific conditions. These conditions could depend
  on the value of another item or a combination of items. Backward and forward transformations must be explicitly
  defined.
- **Split**: An item is split into multiple items. Backward and forward transformations must be explicitly defined.
- **Merge**: Multiple items are merged into a single item. Backward and forward transformations must also be explicitly
  defined.

The next sections provide more details on each form of renaming.

> Note: The `name` field for spans is not yet fully defined within the semantic conventions. Schema changes for spans
> will be addressed in this document once this field is more clearly defined in the semantic conventions.

### Basic renaming

Let's consider the following two consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.process
    type: attribute_group
    brief: "Process attributes."
    attributes:
      - id: process.cpu.state
        brief: "The state of the CPU"
        type: ...
        stability: experimental
```

To rename the `process.cpu.state` attribute to `cpu.mode`, the following changes are made:

```yaml
# Version n+1
groups:
  - id: registry.process.deprecated
    type: attribute_group
    brief: Attributes specific to a cpu instance.
    attributes:
      # The existing attribute is deprecated
      - id: process.cpu.state
        brief: "Deprecated, use `cpu.mode` instead."
        deprecated:
          type: renamed
          new_name: cpu.mode
        type: ...
        stability: experimental
  
  - id: registry.cpu
    type: attribute_group
    brief: Attributes specific to a cpu instance.
    display_name: CPU Attributes
    attributes:
      # A new attribute is introduced
      - id: cpu.mode
        brief: "The mode of the CPU"
        type: ...
        stability: experimental
        examples: [ "user", "system" ]
``` 

From these changes, Weaver can generate a diff report that shows the renaming of the
`process.cpu.state` attribute to `cpu.mode`.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: process.cpu.state
      type: renamed
      new_name: cpu.mode
      note: Deprecated, use `cpu.mode` instead.    
```

### Conditional renaming

Sometimes, the renaming of an item is context-dependent. Let's consider the following
two consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.network
    type: attribute_group
    attributes:
      - id: net.peer.name
        type: string
        stability: experimental
        examples: ['example.com']
        #...
```

To rename the `net.peer.name` attribute to `server.address` on client spans and
`client.address` on server spans, the following changes are made:

```yaml
# Version n+1
groups:
  - id: registry.network.deprecated
    type: attribute_group
    attributes:
      - id: net.peer.name
        type: string
        brief: Deprecated, use `server.address` on client spans and `client.address` on server spans.
        deprecated:
          type: conditionally_renamed
          forward: >
            switch span_kind {
              case 'client' => attributes['server.address'] = attributes['net.peer.name'],
              case 'server' => attributes['client.address'] = attributes['net.peer.name']
            }
          backward: >
            switch span_kind {
              case 'client' => attributes['net.peer.name'] = attributes['server.address'],
              case 'server' => attributes['net.peer.name'] = attributes['client.address']
            }
        stability: experimental
        examples: ['example.com']
```

From these changes, Weaver can generate a diff report that shows the renaming of the
`net.peer.name` attribute into `server.address` on client spans and `client.address`
on server spans.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: net.peer.name
      type: conditionally_renamed
      forward: >
        switch span_kind {
          case 'client' => attributes['server.address'] = attributes['net.peer.name'],
          case 'server' => attributes['client.address'] = attributes['net.peer.name']
        }
      backward: >
        switch span_kind {
          case 'client' => attributes['net.peer.name'] = attributes['server.address'],
          case 'server' => attributes['net.peer.name'] = attributes['client.address']
        }
      note: Deprecated, use `server.address` on client spans and `client.address` on server spans.
```

### Split

There are situations when a single item is split into multiple items. Let's consider the
following two consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.db
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.connection_string
        type: string
        stability: experimental
```

Now, it is decided to split the `db.connection_string` attribute into `server.address` and
`server.port`. These two attributes already exist in the registry.
The following changes are made in the registry to describe this split operation:

```yaml
# Version n+1
groups:
  - id: registry.db.deprecated
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.connection_string
        type: string
        brief: 'Deprecated, use `server.address`, `server.port` attributes instead.'
        deprecated:
          type: split
          into: ["server.address", "server.port"]
          forward: >
            attributes['server.address'] = attributes['db.connection_string'].split(':')[0]
            attributes['server.port'] = attributes['db.connection_string'].split(':')[1]
          backward: attributes['server.address'] + ':' + attributes['server.port']
        stability: experimental
  # server.address and server.port already exist in the registry
  # so they stay unchanged.
```

From these changes, Weaver can generate a diff report that shows the split of the
`db.connection_string` attribute into `server.address` and `server.port`.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: db.connection_string
      type: split
      into: ["server.address", "server.port"]
      forward: >
        attributes['server.address'] = attributes['db.connection_string'].split(':')[0]
        attributes['server.port'] = attributes['db.connection_string'].split(':')[1]
      backward: attributes['server.address'] + ':' + attributes['server.port']
      note: Deprecated, use `server.address`, `server.port` attributes instead.
```

### Merge

There are situations when multiple items are merged into a single item. Let's consider the
following two consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.db
    type: attribute_group
    brief: Deprecated Database Attributes
    stability: experimental
    attributes:
      - id: "db.cassandra.table"
        type: string
      - id: "db.cosmosdb.container"
        type: string
      - id: "db.mongodb.collection"
        type: string
      - id: "db.sql.table"
        type: string
```

Now, it is decided to merge the `db.cassandra.table`, `db.cosmosdb.container`, `db.mongodb.collection`,
and `db.sql.table` attributes into a single attribute `db.collection.name`. It's also decided to introduce
a new attribute `db.system` to store the system name. The following changes are made in the registry to
describe this merge operation:

```yaml
# Version n+1
groups:
  # The existing db attributes are deprecated
  - id: registry.db.deprecated
    type: attribute_group
    stability: experimental
    attributes:
      - id: "db.cassandra.table"
        deprecated:
          type: merged
          merged_to: "db.collection.name"
          backward: >
            if attributes['db.system'] == 'cassandra' then attributes['db.cassandra.table'] = attributes['db.collection.name']
      - id: "db.cosmosdb.container"
        deprecated:
          type: merged
          merged_to: "db.collection.name"
          backward: >
            if attributes['db.system'] == 'cosmosdb' then attributes['db.cosmosdb.container'] = attributes['db.collection.name']
      - id: "db.mongodb.collection"
        deprecated:
          type: merged
          merged_to: "db.collection.name"
          backward: >
            if attributes['db.system'] == 'mongodb' then attributes['db.mongodb.collection'] = attributes['db.collection.name']
      - id: "db.sql.table"
        deprecated:
          type: merged
          merged_to: "db.collection.name"
          backward: >
            if attributes['db.system'] == 'sql' then attributes['db.sql.table'] = attributes['db.collection.name']

  # The new attributes are introduced  
  - id: registry.db
    type: attribute_group
    brief: Database Attributes
    stability: experimental
    attributes:
      - id: "db.collection.name"
        type: string
        brief: "The name of the collection."
      - id: "db.system"
        type: string
        brief: "The system name."
```

From these changes, Weaver can generate a diff report that shows the merge of the
`db.cassandra.table`, `db.cosmosdb.container`, `db.mongodb.collection`, and `db.sql.table`
attributes into a single attribute `db.collection.name`.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: "db.cassandra.table"
      type: merged
      merged_to: "db.collection.name"
      backward: >
        if attributes['db.system'] == 'cassandra' then attributes['db.cassandra.table'] = attributes['db.collection.name']
    - name: "db.cosmosdb.container"
      type: merged
      merged_to: "db.collection.name"
      backward: >
        if attributes['db.system'] == 'cosmosdb' then attributes['db.cosmosdb.container'] = attributes['db.collection.name']
    - name: "db.mongodb.collection"
      type: merged
      merged_to: "db.collection.name"
      backward: >
        if attributes['db.system'] == 'mongodb' then attributes['db.mongodb.collection'] = attributes['db.collection.name']
    - name: "db.sql.table"
      type: merged
      merged_to: "db.collection.name"
      backward: >
        if attributes['db.system'] == 'sql' then attributes['db.sql.table'] = attributes['db.collection.name']
```

The same concept of merging can be applied to signals like metrics, events, and spans.

## Deprecation

Deprecation is the process of marking an item as obsolete or outdated. The renaming of an item is using deprecation but
there are other reasons for deprecation. Sometimes an item is just not needed anymore, it's a form of deletion but without
removing the item from the registry.

There are multiple reasons for deprecation:

- Renaming: An item is renamed to a new name, see the previous section for more details.
- Simple deprecation or Soft removal: An item is marked as deprecated without replacement.
- Conditional deprecation: An item is deprecated based on a condition. The condition can be based on the value of another
  item or a combination of items.
- Generalization: An item is deprecated because it's too specific and a more general item is introduced.

### Soft removal

Soft removal is the process of marking an item as deprecated without removing it from the registry. Let's consider the
following two consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.db.metrics
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.jdbc.driver_classname
        type: string
        stability: experimental
```

To deprecate the `db.jdbc.driver_classname` attribute, the following changes are made in the
next version of the registry:

```yaml
# Version n+1
groups:
  - id: registry.db.metrics.deprecated
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.jdbc.driver_classname
        type: string
        brief: 'Removed, no replacement at this time.'
        deprecated:
          type: deprecated
        stability: experimental
```

From these changes, Weaver can generate a diff report that shows the deprecation of the
`db.jdbc.driver_classname` attribute.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: db.jdbc.driver_classname
      type: deprecated
      note: Removed, no replacement at this time.
```

### Conditional deprecation

Sometimes, the deprecation of an item is context-dependent. Let's consider the following two
consecutive versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: registry.db
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.instance.id
        type: string
        stability: experimental
```

To deprecate the `db.instance.id` attribute based on the value of the `db.system` attribute,
the following changes are made in the next version of the registry. Note that we suppose in this example that
the `db.system` attribute is already defined in the registry.

```yaml
# Version n+1
groups:
  - id: registry.db.deprecated
    type: attribute_group
    stability: experimental
    attributes:
      - id: db.instance.id
        type: string
        brief: 'Deprecated, no general replacement at this time. For Elasticsearch, use `db.elasticsearch.node.name` instead.'
        deprecated:
          type: conditionally_deprecated
          forward: >
            if attributes['db.system'] == 'elasticsearch' then attributes['db.elasticsearch.node.name'] = attributes['db.instance.id']
            else drop attributes['db.instance.id']
          backward: >
            if attributes['db.system'] == 'elasticsearch' then attributes['db.instance.id'] = attributes['db.elasticsearch.node.name']
        stability: experimental
```

From these changes, Weaver can generate a diff report that shows the deprecation of the
`db.instance.id` attribute based on the value of the `db.system` attribute.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
    attributes:
      - name: db.instance.id
        type: conditionally_deprecated
        forward: >
            if attributes['db.system'] == 'elasticsearch' then attributes['db.elasticsearch.node.name'] = attributes['db.instance.id']
            else drop attributes['db.instance.id']
        backward: >
            if attributes['db.system'] == 'elasticsearch' then attributes['db.instance.id'] = attributes['db.elasticsearch.node.name']
        note: Deprecated, no general replacement at this time. For Elasticsearch, use `db.elasticsearch.node.name` instead.
```

### Generalization

Another reason for deprecation is generalization. Let's consider the following two consecutive
versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: "db.table.name"
    # ...
```

The semantic convention authors decide to deprecate the `db.table.name` attribute because it's
too specific and introduce a more general attribute `db.collection.name`. It's not a simple renaming
because this new attribute is more general and represents tables, views, indexes, ...

The following changes are made in the next version of the registry:

```yaml
# Version n+1
groups:
  - id: "db.table.name"
    note: Deprecated, db.collection.name now represents other entities too (indexes, views, table, etc).
    deprecated:
      type: generalized
      generalized_to: "db.collection.name"
      # ...
  - id: "db.collection.name"
    note: Represents the name of a table, a view, an index, ...
```

In this example, there is no backward transformation but we could imagine a scenario where
the `db.table.name` attribute is split into `db.collection.name` and `db.collection.type`.
In this case, the backward and forward transformations could be defined explicitly.

From these changes, Weaver can generate a diff report that shows the deprecation of the
`db.table.name` attribute.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  attributes:
    - name: db.table.name
      type: generalized
      generalized_to: db.collection.name
      note: Deprecated, db.collection.name now represents other entities too (indexes, views, table, etc).
```

## Field and Attribute Changes

The previous sections focused on renaming and deprecation of top-level items (attributes and signals) in the semantic
conventions. This section describes how to handle changes in the fields of attributes and signals and changes in the
attributes of signals.

### Field Changes

There are two types of field changes:

There are two types of field changes:

1. Metadata-Only Changes: Changes made to the notes, descriptions, or examples of an attribute or signal typically have
   no impact on the corresponding telemetry data stream.
2. Data-Impacting Changes: Changes such as modifying the type of an attribute or signal, or altering the unit of a
   metric, can impact the corresponding telemetry data stream. For this second category of field changes, it is often
   necessary to support both backward and forward transformations to ensure compatibility.

The following example shows a change in the unit of a metric between two versions of a semantic convention registry:

```yaml
# Version n
groups:
  - id: metric.db.client.connection.create_time
    type: metric
    metric_name: db.client.connection.create_time
    stability: experimental
    instrument: counter
    unit: "s"
```

The new version of the registry changes the unit of the `db.client.connection.create_time` metric from seconds to milliseconds:

```yaml
# Version n+1
groups:
  - id: metric.db.client.connection.create_time
    type: metric
    metric_name: db.client.connection.create_time
    stability: experimental
    instrument: counter
    unit: "ms"                 # <- This is where the change is made
```

This change is a data-impacting change because it affects the telemetry data stream. To ensure compatibility between
the two versions of the semantic convention registry, backward and forward transformations must be defined.

From these changes, Weaver can generate a diff report that shows the change in the unit of the `db.client.connection.create_time` metric.

```yaml
head:
  semconv_version: n
baseline:
  semconv_version: n+1
changes:
  metrics:
    - name: metric.db.client.connection.create_time
      type: updated
      fields:
        - type: updated
          name: unit
          old_value: s
          new_value: ms
          forward: >
            attributes['db.client.connection.create_time'] = attributes['db.client.connection.create_time'] * 1000
          backward: >
            attributes['db.client.connection.create_time'] = attributes['db.client.connection.create_time'] / 1000
```

In this diff report, Weaver automatically infer the backward and forward transformations to ensure compatibility between
the two versions of the semantic convention registry.

> TBD: Talk about data-impacting changes for which backward and forward transformations must be defined
> manually.

### Attribute Changes

TBD

### Renaming + Field Changes

TBD